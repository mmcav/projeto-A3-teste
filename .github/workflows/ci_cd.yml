name: CI/CD Pipeline

on:
  push:
    branches: [main, release, dev]
  pull_request:
    branches: [main, release, dev]

jobs:
  preflight:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Validação da mensagem de commit
        run: |
          echo "Validando mensagens de commit..."

          # Regex para validar a mensagem do commit
          REGEX="^((Merge.*)|(Revert.*)|((build|chore|ci|docs|feat|fix|perf|refactor|revert|style|test)(\(.*\))?!?: .*))"
        
          # Se a tag de base não existir, use o primeiro commit do repositório
          BASE_TAG=your-base-tag  # Substitua com o nome da sua tag de base
          if git rev-parse $BASE_TAG >/dev/null 2>&1; then
              COMMIT_RANGE=$BASE_TAG..HEAD
          else
              COMMIT_RANGE=$(git rev-list --max-parents=0 HEAD)
          fi
        
          # Loop para validar todas as mensagens de commit no intervalo
          for COMMIT_HASH in $(git rev-list --no-merges $COMMIT_RANGE); do
              MESSAGE=$(git log --format=%B -n 1 $COMMIT_HASH)
              echo "Commit Message: ${MESSAGE}"
              if ! [[ "$MESSAGE" =~ $REGEX ]]; then
                  echo >&2 "ERROR: Commit aborted for not following the Conventional Commit standard."
                  exit 1
              else
                  echo "Valid commit message!"
              fi
          done

  build:
    runs-on: ubuntu-latest
    needs: preflight
    steps:
      - uses: actions/checkout@v4
      - name: Instalação do JDK for x64
        uses: actions/setup-java@v4
        with:
          java-version: '20'
          distribution: 'temurin'
          architecture: x64
          cache: 'maven'
      - name: Fase compilação do Maven
        run: mvn --batch-mode --update-snapshots compile

  test:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - uses: actions/checkout@v4
      - name: Rodar testes unitários
        run: mvn --batch-mode --update-snapshots test

  integration:
    runs-on: ubuntu-latest
    needs: test
    if: github.ref == 'refs/heads/release'
    steps:
      - uses: actions/checkout@v4
      - name: Rodar testes de integração
        run: echo "WIP"

  versioning:
    runs-on: ubuntu-latest
    needs: integration
    permissions:
      contents: write
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Configuração do Git
        run: |
          git config --local user.email "actions@github.com"
          git config --local user.name "GitHub Actions"
      - name: Tag release
        run: |
          GENERATE_VERSION=true
          echo "Generate version: $GENERATE_VERSION"

          PREVENT_REMOVE_FILE=$2

          LAST_TAG=$(git describe --tags --abbrev=0 --always)
          echo "Last tag: #$LAST_TAG#"
          PATTERN="^[0-9]+\.[0-9]+\.[0-9]+$"

          increment_version() {
              local version=$1
              local increment=$2
              local major=$(echo $version | cut -d. -f1)
              local minor=$(echo $version | cut -d. -f2)
              local patch=$(echo $version | cut -d. -f3)

              if [ "$increment" == "major" ]; then
                  major=$((major + 1))
                  minor=0
                  patch=0
              elif [ "$increment" == "minor" ]; then
                  minor=$((minor + 1))
                  patch=0
              elif [ "$increment" == "patch" ]; then
                  patch=$((patch + 1))
              fi

              echo "${major}.${minor}.${patch}"
          }

          push_newversion() {
              local new_version=$1
              if [ "$GENERATE_VERSION" == "true" ]; then
                  echo "Generating new version..."
                  git tag $new_version
                  git push origin $new_version
              else
                  echo "To generate a new version, you must send the argument \"true\""
              fi
          }

          create_file() {
              local with_range=$1
              if [ -s messages.txt ]; then
                  return 1
              fi
              if [ "$with_range" == "true" ]; then
                  git log $LAST_TAG..HEAD --no-decorate --pretty=format:"%s" > messages.txt
              else
                  git log --no-decorate --pretty=format:"%s" > messages.txt
              fi
          }

          get_commit_range() {
              if [[ $LAST_TAG =~ $PATTERN ]]; then
                  create_file true
              else
                  create_file
                  LAST_TAG="0.0.0"
              fi
              echo " " >> messages.txt
          }

          start() {
              get_commit_range
              new_version=$LAST_TAG
              increment_type=""

              cat messages.txt
              
              while read message; do
                  if [[ $message =~ (([a-z]+)(\(.+\))?\!:)|(BREAKING CHANGE:) ]]; then
                      increment_type="major"
                      break
                  elif [[ $message =~ (^(feat|style)(\(.+\))?:) ]]; then
                      if [ -z "$increment_type" ] || [ "$increment_type" == "patch" ]; then
                          increment_type="minor"
                      fi
                  elif [[ $message =~ ^((fix|build|perf|refactor|revert)(\(.+\))?:) ]]; then
                      if [ -z "$increment_type" ]; then
                          increment_type="patch"
                      fi
                  fi
              done < messages.txt

              if [ -n "$increment_type" ]; then
                  new_version=$(increment_version $LAST_TAG $increment_type)
                  echo "New version: $new_version"
                  push_newversion $new_version
              else
                  echo "No changes requiring a version increment."
              fi
          }

          start

          if [ -z "$PREVENT_REMOVE_FILE" ]; then
              rm -f messages.txt
          fi
